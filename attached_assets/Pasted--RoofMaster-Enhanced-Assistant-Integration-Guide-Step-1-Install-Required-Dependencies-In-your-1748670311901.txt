# RoofMaster Enhanced Assistant Integration Guide

## Step 1: Install Required Dependencies

In your Replit console, run:
```bash
npm install natural uuid
```

## Step 2: Update package.json

Add these dependencies to your `package.json` if they're not already there:
```json
{
  "dependencies": {
    "natural": "^6.5.0",
    "uuid": "^9.0.0"
  }
}
```

## Step 3: Backend Integration

### Create/Update: `routes/assistant.js`

Create a new file called `assistant.js` in your `routes` folder (or create the routes folder if it doesn't exist). Copy this entire code:

```javascript
const express = require('express');
const router = express.Router();
const natural = require('natural');
const { v4: uuidv4 } = require('uuid');

// In-memory conversation storage (use Redis or database in production)
const conversations = new Map();

// Enhanced knowledge base
const roofingKnowledge = {
  emergencyKeywords: [
    'leak', 'water damage', 'collapsed', 'emergency', 'urgent', 
    'storm damage', 'tree fell', 'hole', 'flooding', 'water coming in'
  ],
  
  problemTypes: {
    'missing_shingles': {
      urgency: 'medium',
      timeline: '2-4 weeks',
      costRange: '$300-800',
      seasonalFactors: ['wind damage', 'age deterioration'],
      questions: [
        'How many shingles are missing?',
        'Can you see the underlying roof deck?',
        'Has there been recent severe weather?'
      ]
    },
    'leak': {
      urgency: 'high',
      timeline: '24-48 hours',
      costRange: '$400-1500',
      seasonalFactors: ['ice dams', 'heavy rain', 'snow melt'],
      questions: [
        'Where exactly is the water coming from?',
        'Is it actively leaking now?',
        'How long has this been happening?'
      ]
    },
    'gutter_issues': {
      urgency: 'low',
      timeline: '1-3 months',
      costRange: '$200-1200',
      seasonalFactors: ['fall leaf blockage', 'ice formation'],
      questions: [
        'Are gutters overflowing or sagging?',
        'When were they last cleaned?',
        'Do you see any detachment points?'
      ]
    },
    'storm_damage': {
      urgency: 'high',
      timeline: '1-2 weeks',
      costRange: '$1000-5000+',
      seasonalFactors: ['hail', 'high winds', 'fallen trees'],
      questions: [
        'What type of storm occurred?',
        'When did the damage happen?',
        'Have you contacted your insurance company?'
      ]
    },
    'hail_damage': {
      urgency: 'medium',
      timeline: '2-6 weeks',
      costRange: '$5000-15000',
      seasonalFactors: ['Colorado hail season'],
      questions: [
        'What size was the hail?',
        'Do you see dents on metal surfaces?',
        'Has an adjuster inspected the damage?'
      ]
    }
  },

  responses: {
    greeting: [
      "Hello! I'm Spencer Roofing's AI assistant. I'm here to help with any roofing questions or concerns you might have. What brings you here today?",
      "Hi there! I'm here to help you with your roofing needs. I've assisted thousands of Denver area homeowners. What's going on with your roof today?",
      "Welcome! I'm Spencer Roofing's virtual assistant. Whether it's an emergency or routine maintenance, I'm here to help. How can I assist you?"
    ],
    
    emergency: "ðŸš¨ This sounds like an emergency! For immediate assistance, please call us at (720) 360-8546. Our emergency line is available 24/7. In the meantime, if there's active water intrusion, try to contain it with buckets and tarps if it's safe to do so.",
    
    appointment_confirmation: "Perfect! I'm connecting you with our scheduling team for a priority appointment. You should receive a call within the next 2 hours to confirm your appointment time."
  }
};

// Natural language processing setup
const tokenizer = new natural.WordTokenizer();
const stemmer = natural.PorterStemmer;

// Conversation state management
class ConversationManager {
  constructor() {
    this.conversations = new Map();
  }

  createConversation(sessionId) {
    const conversation = {
      id: sessionId,
      messages: [],
      state: {
        stage: 'greeting',
        customerInfo: {},
        problemDetails: {},
        urgency: 'normal',
        leadScore: 0,
        lastActivity: new Date()
      }
    };
    this.conversations.set(sessionId, conversation);
    return conversation;
  }

  getConversation(sessionId) {
    return this.conversations.get(sessionId);
  }

  updateConversation(sessionId, updates) {
    const conversation = this.conversations.get(sessionId);
    if (conversation) {
      conversation.state = { ...conversation.state, ...updates, lastActivity: new Date() };
      this.conversations.set(sessionId, conversation);
    }
    return conversation;
  }

  addMessage(sessionId, message) {
    const conversation = this.conversations.get(sessionId);
    if (conversation) {
      conversation.messages.push({
        id: uuidv4(),
        ...message,
        timestamp: new Date()
      });
      conversation.state.lastActivity = new Date();
      this.conversations.set(sessionId, conversation);
    }
  }
}

const conversationManager = new ConversationManager();

// AI Response Generator
class RoofingAI {
  constructor() {
    this.knowledge = roofingKnowledge;
  }

  analyzeMessage(text) {
    const tokens = tokenizer.tokenize(text.toLowerCase());
    const stems = tokens.map(token => stemmer.stem(token));
    
    return {
      urgency: this.detectUrgency(text),
      problemType: this.identifyProblem(text),
      intent: this.detectIntent(stems),
      entities: this.extractEntities(text),
      sentiment: this.analyzeSentiment(text)
    };
  }

  detectUrgency(text) {
    const lowerText = text.toLowerCase();
    
    // Emergency detection
    const emergencyWords = this.knowledge.emergencyKeywords;
    if (emergencyWords.some(word => lowerText.includes(word))) {
      return 'emergency';
    }
    
    // High urgency indicators
    const highUrgencyWords = ['asap', 'soon', 'quickly', 'today', 'now'];
    if (highUrgencyWords.some(word => lowerText.includes(word))) {
      return 'high';
    }
    
    // Low urgency indicators
    const lowUrgencyWords = ['eventually', 'someday', 'planning', 'future'];
    if (lowUrgencyWords.some(word => lowerText.includes(word))) {
      return 'low';
    }
    
    return 'medium';
  }

  identifyProblem(text) {
    const lowerText = text.toLowerCase();
    
    for (const [problemKey, problemData] of Object.entries(this.knowledge.problemTypes)) {
      const keywords = problemKey.split('_');
      if (keywords.some(keyword => lowerText.includes(keyword))) {
        return { type: problemKey, data: problemData };
      }
    }
    
    return null;
  }

  detectIntent(stems) {
    const intents = {
      schedule: ['schedul', 'appoint', 'meet', 'visit', 'inspect'],
      quote: ['cost', 'price', 'quot', 'estimat', 'much'],
      emergency: ['help', 'emerg', 'urgent', 'fix'],
      information: ['what', 'how', 'why', 'when', 'tell', 'explain']
    };

    for (const [intent, keywords] of Object.entries(intents)) {
      if (keywords.some(keyword => stems.includes(keyword))) {
        return intent;
      }
    }
    
    return 'general';
  }

  extractEntities(text) {
    const entities = {};
    
    // Extract potential addresses
    const addressRegex = /\d+\s+[A-Za-z\s]+(?:street|st|avenue|ave|road|rd|drive|dr|lane|ln|way|court|ct)/gi;
    const addresses = text.match(addressRegex);
    if (addresses) entities.address = addresses[0];
    
    // Extract phone numbers
    const phoneRegex = /(\d{3}[-.]?\d{3}[-.]?\d{4})/g;
    const phones = text.match(phoneRegex);
    if (phones) entities.phone = phones[0];
    
    // Extract time references
    const timeRegex = /(today|tomorrow|this week|next week|monday|tuesday|wednesday|thursday|friday|saturday|sunday)/gi;
    const timeRefs = text.match(timeRegex);
    if (timeRefs) entities.timePreference = timeRefs[0];
    
    return entities;
  }

  analyzeSentiment(text) {
    // Simple sentiment analysis
    const positiveWords = ['good', 'great', 'excellent', 'happy', 'satisfied', 'pleased'];
    const negativeWords = ['bad', 'terrible', 'awful', 'frustrated', 'angry', 'disappointed'];
    
    const lowerText = text.toLowerCase();
    const positiveCount = positiveWords.filter(word => lowerText.includes(word)).length;
    const negativeCount = negativeWords.filter(word => lowerText.includes(word)).length;
    
    if (positiveCount > negativeCount) return 'positive';
    if (negativeCount > positiveCount) return 'negative';
    return 'neutral';
  }

  generateResponse(analysis, conversationState) {
    const { urgency, problemType, intent, entities, sentiment } = analysis;
    
    // Handle emergency cases
    if (urgency === 'emergency') {
      return {
        text: this.knowledge.responses.emergency,
        options: [
          { text: "Call Now", action: "call", data: "7203608546" },
          { text: "I'll handle it myself for now", action: "continue" }
        ],
        updateState: { urgency: 'emergency', stage: 'emergency_handled' }
      };
    }

    // Handle specific problems
    if (problemType) {
      const problem = problemType.data;
      const response = `I understand you're dealing with ${problemType.type.replace('_', ' ')}. Based on my experience, this is typically a ${problem.urgency} priority issue. Here in Colorado, we usually recommend addressing this within ${problem.timeline}. The typical cost range is ${problem.costRange}.

Would you like me to help you schedule a free inspection, or do you have specific questions about the repair process?`;

      return {
        text: response,
        options: [
          { text: "Schedule Free Inspection", action: "schedule" },
          { text: "Learn about repair process", action: "explain_process", data: problemType.type },
          { text: "Get cost details", action: "cost_breakdown", data: problemType.type }
        ],
        updateState: { 
          problemDetails: problemType, 
          stage: 'problem_identified',
          leadScore: conversationState.leadScore + 20
        }
      };
    }

    // Handle scheduling intent
    if (intent === 'schedule') {
      return {
        text: "Great choice! Our free inspections are thorough and typically take 30-45 minutes. We'll provide you with a detailed report and photos. What's your address, and when would be a good time for you?",
        options: [
          { text: "This week", action: "schedule_timeframe", data: "this_week" },
          { text: "Next week", action: "schedule_timeframe", data: "next_week" },
          { text: "I'm flexible", action: "schedule_timeframe", data: "flexible" }
        ],
        updateState: { 
          stage: 'scheduling',
          leadScore: conversationState.leadScore + 30
        }
      };
    }

    // Handle quote requests
    if (intent === 'quote') {
      return {
        text: "I'd be happy to help you understand pricing! Roofing costs depend on several factors including size, materials, and complexity. To give you an accurate estimate, we'd need to do a free inspection. Would you like to learn about our different material options first, or shall we schedule an inspection?",
        options: [
          { text: "Learn about materials", action: "materials_info" },
          { text: "Schedule inspection for quote", action: "schedule" },
          { text: "Give me a rough estimate", action: "rough_estimate" }
        ],
        updateState: { 
          stage: 'pricing_discussion',
          leadScore: conversationState.leadScore + 15
        }
      };
    }

    // Default conversational responses based on stage
    switch (conversationState.stage) {
      case 'greeting':
        return {
          text: "I'd be happy to help! To give you the most accurate information, could you tell me a bit more about what's happening with your roof?",
          options: [
            { text: "I see damage on my roof", action: "damage_report" },
            { text: "I need maintenance", action: "maintenance" },
            { text: "I want a roof replacement", action: "replacement" },
            { text: "I have questions about materials", action: "materials_info" }
          ],
          updateState: { stage: 'problem_identification' }
        };
        
      default:
        return {
          text: "Thanks for that information. To help you better, could you be more specific about the issue you're experiencing? For example, are you seeing any visible damage, leaks, or other concerns?",
          options: [
            { text: "There's visible damage", action: "damage_report" },
            { text: "I have a leak", action: "leak_report" },
            { text: "Just general maintenance", action: "maintenance" }
          ]
        };
    }
  }
}

const roofingAI = new RoofingAI();

// Lead scoring system
class LeadScorer {
  static calculateScore(conversationState) {
    let score = 0;
    
    // Urgency scoring
    switch (conversationState.urgency) {
      case 'emergency': score += 50; break;
      case 'high': score += 30; break;
      case 'medium': score += 20; break;
      case 'low': score += 10; break;
    }
    
    // Problem type scoring
    if (conversationState.problemDetails) {
      const problemUrgency = conversationState.problemDetails.data?.urgency;
      if (problemUrgency === 'high') score += 25;
      if (problemUrgency === 'medium') score += 15;
    }
    
    // Engagement scoring
    const messageCount = conversationState.messages?.length || 0;
    score += Math.min(messageCount * 2, 20);
    
    // Intent scoring
    if (conversationState.stage === 'scheduling') score += 40;
    if (conversationState.stage === 'pricing_discussion') score += 30;
    
    return Math.min(score, 100);
  }
}

// API Routes

// Initialize conversation
router.post('/chat/init', (req, res) => {
  const sessionId = req.body.sessionId || uuidv4();
  const conversation = conversationManager.createConversation(sessionId);
  
  // Add initial greeting
  const greetingIndex = Math.floor(Math.random() * roofingKnowledge.responses.greeting.length);
  const greeting = roofingKnowledge.responses.greeting[greetingIndex];
  
  conversationManager.addMessage(sessionId, {
    text: greeting,
    sender: 'bot',
    options: [
      { text: "I have a roofing emergency", action: "emergency" },
      { text: "I need an inspection", action: "schedule" },
      { text: "I have questions", action: "questions" }
    ]
  });

  res.json({
    sessionId,
    message: greeting,
    options: [
      { text: "I have a roofing emergency", action: "emergency" },
      { text: "I need an inspection", action: "schedule" },
      { text: "I have questions", action: "questions" }
    ]
  });
});

// Process message
router.post('/chat/message', async (req, res) => {
  try {
    const { sessionId, message, action } = req.body;
    
    if (!sessionId || !message) {
      return res.status(400).json({ error: 'Session ID and message are required' });
    }

    let conversation = conversationManager.getConversation(sessionId);
    if (!conversation) {
      conversation = conversationManager.createConversation(sessionId);
    }

    // Add user message
    conversationManager.addMessage(sessionId, {
      text: message,
      sender: 'user'
    });

    // Analyze message
    const analysis = roofingAI.analyzeMessage(message);
    
    // Generate AI response
    const aiResponse = roofingAI.generateResponse(analysis, conversation.state);
    
    // Update conversation state
    if (aiResponse.updateState) {
      conversationManager.updateConversation(sessionId, aiResponse.updateState);
    }

    // Add bot response
    conversationManager.addMessage(sessionId, {
      text: aiResponse.text,
      sender: 'bot',
      options: aiResponse.options
    });

    // Calculate lead score
    const updatedConversation = conversationManager.getConversation(sessionId);
    const leadScore = LeadScorer.calculateScore(updatedConversation.state);
    conversationManager.updateConversation(sessionId, { leadScore });

    // If high-value lead, trigger notifications
    if (leadScore > 70) {
      console.log(`High-value lead detected: ${sessionId}, Score: ${leadScore}`);
    }

    res.json({
      response: aiResponse.text,
      options: aiResponse.options,
      leadScore,
      urgency: analysis.urgency,
      conversationState: updatedConversation.state
    });

  } catch (error) {
    console.error('Error processing message:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      response: "I apologize, but I'm having trouble processing your request right now. Please try again, or call us directly at (720) 360-8546 for immediate assistance."
    });
  }
});

// Handle specific actions
router.post('/chat/action', async (req, res) => {
  try {
    const { sessionId, action, data } = req.body;
    
    let conversation = conversationManager.getConversation(sessionId);
    if (!conversation) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    let response = {};

    switch (action) {
      case 'schedule_timeframe':
        response = {
          text: `Perfect! I'll connect you with our scheduling team for a ${data === 'this_week' ? 'priority' : 'standard'} appointment. Can you provide your address and the best phone number to reach you?`,
          updateState: { 
            stage: 'collecting_contact_info',
            timePreference: data,
            leadScore: conversation.state.leadScore + 25
          }
        };
        break;

      case 'emergency':
        response = {
          text: roofingKnowledge.responses.emergency,
          updateState: { urgency: 'emergency', leadScore: conversation.state.leadScore + 50 }
        };
        break;

      default:
        response = {
          text: "I understand. How else can I help you today?",
          options: [
            { text: "Schedule inspection", action: "schedule" },
            { text: "Get cost information", action: "quote" },
            { text: "Learn about our company", action: "company_info" }
          ]
        };
    }

    // Update conversation state
    if (response.updateState) {
      conversationManager.updateConversation(sessionId, response.updateState);
    }

    // Add bot response
    conversationManager.addMessage(sessionId, {
      text: response.text,
      sender: 'bot',
      options: response.options
    });

    const updatedConversation = conversationManager.getConversation(sessionId);
    const leadScore = LeadScorer.calculateScore(updatedConversation.state);

    res.json({
      response: response.text,
      options: response.options,
      leadScore,
      conversationState: updatedConversation.state
    });

  } catch (error) {
    console.error('Error handling action:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get analytics data
router.get('/analytics/conversations', (req, res) => {
  const conversations = Array.from(conversationManager.conversations.values());
  
  const analytics = {
    totalConversations: conversations.length,
    highValueLeads: conversations.filter(c => LeadScorer.calculateScore(c.state) > 70).length,
    emergencies: conversations.filter(c => c.state.urgency === 'emergency').length,
    averageLeadScore: conversations.reduce((sum, c) => sum + LeadScorer.calculateScore(c.state), 0) / conversations.length,
    commonProblems: {},
    conversionFunnel: {
      initiated: conversations.length,
      problemIdentified: conversations.filter(c => c.state.stage === 'problem_identified').length,
      scheduling: conversations.filter(c => c.state.stage === 'scheduling').length,
      contactCollected: conversations.filter(c => c.state.stage === 'collecting_contact_info').length
    }
  };

  // Calculate common problems
  conversations.forEach(c => {
    if (c.state.problemDetails?.type) {
      const problem = c.state.problemDetails.type;
      analytics.commonProblems[problem] = (analytics.commonProblems[problem] || 0) + 1;
    }
  });

  res.json(analytics);
});

module.exports = router;
```

## Step 4: Update Your Main Server File

In your main server file (likely `server.js` or `index.js`), add this line after your existing route imports:

```javascript
// Add this import at the top with your other route imports
const assistantRoutes = require('./routes/assistant');

// Add this line after your existing route definitions
app.use('/api/assistant', assistantRoutes);
```

## Step 5: Create the Frontend Component

### Create: `src/components/RoofingAssistant.jsx`

Create this file in your components directory:

```jsx
import React, { useState, useRef, useEffect } from 'react';
import { MessageCircle, Send, X, Phone, Camera, AlertTriangle } from 'lucide-react';

const RoofingAssistant = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [sessionId, setSessionId] = useState(null);
  const [isTyping, setIsTyping] = useState(false);
  const [urgency, setUrgency] = useState('normal');
  const messagesEndRef = useRef(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  useEffect(() => {
    if (isOpen && !sessionId) {
      initializeChat();
    }
  }, [isOpen]);

  const initializeChat = async () => {
    try {
      const response = await fetch('/api/assistant/chat/init', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({})
      });
      
      const data = await response.json();
      setSessionId(data.sessionId);
      
      setMessages([{
        id: Date.now(),
        text: data.message,
        sender: 'bot',
        options: data.options,
        timestamp: new Date()
      }]);
    } catch (error) {
      console.error('Error initializing chat:', error);
      setMessages([{
        id: Date.now(),
        text: "Hello! I'm here to help with your roofing needs. How can I assist you today?",
        sender: 'bot',
        timestamp: new Date()
      }]);
    }
  };

  const simulateTyping = (duration = 1000) => {
    setIsTyping(true);
    return new Promise(resolve => {
      setTimeout(() => {
        setIsTyping(false);
        resolve();
      }, duration);
    });
  };

  const sendMessage = async (message) => {
    if (!sessionId) return;

    try {
      await simulateTyping(500);
      
      const response = await fetch('/api/assistant/chat/message', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sessionId,
          message
        })
      });

      const data = await response.json();
      
      if (data.urgency) {
        setUrgency(data.urgency);
      }

      setMessages(prev => [...prev, {
        id: Date.now(),
        text: data.response,
        sender: 'bot',
        options: data.options,
        timestamp: new Date()
      }]);

    } catch (error) {
      console.error('Error sending message:', error);
      setMessages(prev => [...prev, {
        id: Date.now(),
        text: "I'm sorry, I'm having trouble processing your request. Please try again or call us at (720) 360-8546.",
        sender: 'bot',
        timestamp: new Date()
      }]);
    }
  };

  const handleQuickResponse = async (option) => {
    // Add user message
    setMessages(prev => [...prev, {
      id: Date.now(),
      text: option.text,
      sender: 'user',
      timestamp: new Date()
    }]);

    if (option.action === 'call') {
      window.open(`tel:${option.data}`);
      return;
    }

    try {
      await simulateTyping(500);
      
      const response = await fetch('/api/assistant/chat/action', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sessionId,
          action: option.action,
          data: option.data
        })
      });

      const data = await response.json();
      
      setMessages(prev => [...prev, {
        id: Date.now(),
        text: data.response,
        sender: 'bot',
        options: data.options,
        timestamp: new Date()
      }]);

    } catch (error) {
      console.error('Error handling quick response:', error);
    }
  };

  const handleSendMessage = async () => {
    if (!inputValue.trim()) return;
    
    const userMessage = inputValue;
    setInputValue('');
    
    // Add user message
    setMessages(prev => [...prev, {
      id: Date.now(),
      text: userMessage,
      sender: 'user',
      timestamp: new Date()
    }]);
    
    await sendMessage(userMessage);
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  return (
    <div className="fixed bottom-4 right-4 z-50">
      {!isOpen && (
        <button
          onClick={() => setIsOpen(true)}
          className="bg-blue-600 hover:bg-blue-700 text-white p-4 rounded-full shadow-lg transition-all duration-300 animate-pulse"
        >
          <MessageCircle size={24} />
        </button>
      )}
      
      {isOpen && (
        <div className="bg-white rounded-lg shadow-2xl w-96 h-[600px] flex flex-col border border-gray-200">
          {/* Header */}
          <div className="bg-blue-600 text-white p-4 rounded-t-lg flex justify-between items-center">
            <div className="flex items-center space-x-2">
              <div className="w-3 h-3 bg-green-400 rounded-full animate-pulse"></div>
              <span className="font-semibold">Spencer Roofing Assistant</span>
            </div>
            <button
              onClick={() => setIsOpen(false)}
              className="text-white hover:text-gray-300 transition-colors"
            >
              <X size={20} />
            </button>
          </div>

          {/* Emergency Banner */}
          {urgency === 'emergency' && (
            <div className="bg-red-100 border-l-4 border-red-500 p-3 flex items-center space-x-2">
              <AlertTriangle size={16} className="text-red-500" />
              <span className="text-red-700 text-sm font-medium">Emergency Detected - Priority Support</span>
            </div>
          )}

          {/* Messages */}
          <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-gray-50">
            {messages.map((message) => (
              <div
                key={message.id}
                className={`flex ${message.sender === 'user' ? 'justify-end' : 'justify-start'}`}
              >
                <div
                  className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                    message.sender === 'user'
                      ? 'bg-blue-600 text-white'
                      : 'bg-white text-gray-800 shadow-sm border'
                  }`}
                >
                  <p className="text-sm whitespace-pre-wrap">{message.text}</p>
                  {message.options && (
                    <div className="mt-3 space-y-2">
                      {message.options.map((option, index) => (
                        <button
                          key={index}
                          onClick={() => handleQuickResponse(option)}
                          className="block w-full text-left px-3 py-2 text-sm bg-blue-50 hover:bg-blue-100 rounded border text-blue-700 transition-colors"
                        >
                          {option.text}
                        </button>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            ))}
            
            {isTyping && (
              <div className="flex justify-start">
                <div className="bg-white text-gray-800 shadow-sm border px-4 py-2 rounde